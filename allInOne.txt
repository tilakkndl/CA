Computer Architecture Practical 
1’s and 2’s complement in C
The 2s complement in C is generated from the 1s complement in C. As we know that the 1s complement of a binary number is created by transforming bit 1 to 0 and 0 to 1; the 2s complement of a binary number is generated by adding one to the 1s complement of a binary number.
In short, we can say that the 2s complement in C is defined as the sum of the one's complement in C and one.
 
In the above figure, the binary number is equal to 00010100, and its one's complement is calculated by transforming the bit 1 to 0 and 0 to 1 vice versa. Therefore, one's complement becomes 11101011. After calculating one's complement, we calculate the two's complement by adding 1 to the one's complement, and its result is 11101100.
Program 
#include <stdio.h>  
int main()  
{  
   int n;  // variable declaration  
   printf("Enter the number of bits do you want to enter :");  
   scanf("%d",&n);  
   char binary[n+1];  // binary array declaration;   
   char onescomplement[n+1]; // onescomplement array declaration   
   char twoscomplement[n+1]; // twoscomplement array declaration  
   int carry=1; // variable initialization  
   printf("\nEnter the binary number : ");  
   scanf("%s", binary);  
   printf("%s", binary);  
   printf("\nThe ones complement of the binary number is :");  
     
   // Finding onescomplement in C  
   for(int i=0;i<n;i++)  
   {  
       if(binary[i]=='0')  
       onescomplement[i]='1';  
       else if(binary[i]=='1')  
       onescomplement[i]='0';  
   }  
   onescomplement[n]='\0';  
   printf("%s",onescomplement);  
    
  
printf("\nThe twos complement of a binary number is : ");  
  
// Finding two’ s complement in C  
for(int i=n-1; i>=0; i--)  
    {  
        if(onescomplement[i] == '1' && carry == 1)  
        {  
            twoscomplement[i] = '0';  
        }  
        else if(onescomplement[i] == '0' && carry == 1)  
        {  
            twoscomplement[i] = '1';  
            carry = 0;  
        }  
        else  
        {  
            twoscomplement[i] = onescomplement[i];  
        }  
    }  
twoscomplement[n]='\0';  
printf("%s",twoscomplement);  
return 0;  
}  

Half Adder
Half adder is used for adding two bit.There are two input and two output in half adder.
 
Truth Table:
 
Circuit Diagram:
 
Sum = A XOR B
Carry = A AND B
Program in C:
 #include <stdio.h>
 #include <conio.h>

 typedef char bit;
 bit carry=0;
bit halfadd(bit A,bit B){
 carry=A&B;
   return A^B;
 }
int main()
{
 int i,j,result;
 printf("A   B  |  S  Carry\n");
 for(i=0;i<2;i++)
 {
  for(j=0;j<2;j++)
  {
   result=halfadd(i,j);
   printf("%d   %d  |  ",i,j);
   printf("%d   %d\n",result,carry);
  }
 }
 return 0;
}
Full Adder
Full Adder is a combinational logic circuit that performs the arithmetic sum of three inputs bits. There are three inputs and two outputs in Full adder.
 
Truth Table:
 
Circuit Diagram: 
 

Sum = A XOR B XOR C_in
C_out = A.B + B.C_in + A.C_in
Program in C:
#include <stdio.h>
 typedef char bit;
 bit Cout=0;
 bit fulladd(bit A ,bit B,bit Cin){
 Cout=(A&B)||Cin&(A^B));
 return (A^B)^Cin;
  }
 int main()
 {
  int i,j,k;
  int result;
 printf("A   B   Cin  |  S  Cout\n");
 for(i=0;i<2;i++)
 {
  for(j=0;j<2;j++)
  {
   for(k=0;k<2;k++)
   {
   result=fulladd(i,j,k);
  printf("%d   %d   %d    |  ",i,j,k);
  printf("%d    %d\n",result,Cout);
 } }
    }
 return 0;
}

Booth’s Multiplication Algorithm
Booth’s algorithm is a multiplication algorithm that multiplies two signed binary numbers in 2’s complement notation. 
Booth used desk calculators that were faster at shifting than adding and created the algorithm to increase their speed. Booth’s algorithm is of interest in the study of computer architecture. Here’s the implementation of the algorithm. 
Examples: 
 
Input : 0110, 0010
Output :  qn      q[n+1]                  AC      QR     sc(step count)
                          initial         0000   0010        4
          0       0       rightShift      0000   0001        3
          1       0       A = A - BR      1010
                          rightShift      1101   0000        2
          0       1       A = A + BR      0011
                          rightShift      0001   1000        1
          0       0       rightShift      0000   1100        0

Result=1100


Program
#include <stdio.h>
#include <math.h>
 
int a = 0,b = 0, c = 0, a1 = 0, b1 = 0, com[5] = { 1, 0, 0, 0, 0};
int anum[5] = {0}, anumcp[5] = {0}, bnum[5] = {0};
int acomp[5] = {0}, bcomp[5] = {0}, pro[5] = {0}, res[5] = {0};
 
void binary(){
     a1 = fabs(a);
     b1 = fabs(b);
     int r, r2, i, temp;
     for (i = 0; i < 5; i++){
           r = a1 % 2;
           a1 = a1 / 2;
           r2 = b1 % 2;
           b1 = b1 / 2;
           anum[i] = r;
           anumcp[i] = r;
           bnum[i] = r2;
           if(r2 == 0){
                bcomp[i] = 1;
           }
           if(r == 0){
                acomp[i] =1;
           }
     }
   //part for two's complementing
   c = 0;
   for ( i = 0; i < 5; i++){
           res[i] = com[i]+ bcomp[i] + c;
           if(res[i] >= 2){
                c = 1;
           }
           else
                c = 0;
           res[i] = res[i] % 2;
     }
   for (i = 4; i >= 0; i--){
     bcomp[i] = res[i];
   }
   //in case of negative inputs
   if (a < 0){
      c = 0;
     for (i = 4; i >= 0; i--){
           res[i] = 0;
     }
     for ( i = 0; i < 5; i++){
           res[i] = com[i] + acomp[i] + c;
           if (res[i] >= 2){
                c = 1;
           }
           else
                c = 0;
           res[i] = res[i]%2;
     }
     for (i = 4; i >= 0; i--){
           anum[i] = res[i];
           anumcp[i] = res[i];
     }
 
   }
   if(b < 0){
     for (i = 0; i < 5; i++){
           temp = bnum[i];
           bnum[i] = bcomp[i];
           bcomp[i] = temp;
     }
   }
}
void add(int num[]){
    int i;
    c = 0;
    for ( i = 0; i < 5; i++){
           res[i] = pro[i] + num[i] + c;
           if (res[i] >= 2){
                c = 1;
           }
           else{
                c = 0;
           } 
           res[i] = res[i]%2;
     }
     for (i = 4; i >= 0; i--){
         pro[i] = res[i];
         printf("%d",pro[i]);
     }
   printf(":");
   for (i = 4; i >= 0; i--){
           printf("%d", anumcp[i]);
     }
}
void arshift(){//for arithmetic shift right
    int temp = pro[4], temp2 = pro[0], i;
    for (i = 1; i < 5  ; i++){//shift the MSB of product
       pro[i-1] = pro[i];
    }
    pro[4] = temp;
    for (i = 1; i < 5  ; i++){//shift the LSB of product
        anumcp[i-1] = anumcp[i];
    }
    anumcp[4] = temp2;
    printf("\nAR-SHIFT: ");//display together
    for (i = 4; i >= 0; i--){
        printf("%d",pro[i]);
    }
    printf(":");
    for(i = 4; i >= 0; i--){
        printf("%d", anumcp[i]);
    }
}
 
void main(){
   int i, q = 0;
   printf("\t\tBOOTH'S MULTIPLICATION ALGORITHM");
   printf("\nEnter two numbers to multiply: ");
   printf("\nBoth must be less than 16");
   //simulating for two numbers each below 16
   do{
        printf("\nEnter A: ");
        scanf("%d",&a);
        printf("Enter B: ");
        scanf("%d", &b);
     }while(a >=16 || b >=16);
 
    printf("\nExpected product = %d", a * b);
    binary();
    printf("\n\nBinary Equivalents are: ");
    printf("\nA = ");
    for (i = 4; i >= 0; i--){
        printf("%d", anum[i]);
    }
    printf("\nB = ");
    for (i = 4; i >= 0; i--){
        printf("%d", bnum[i]);
    }
    printf("\nB'+ 1 = ");
    for (i = 4; i >= 0; i--){
        printf("%d", bcomp[i]);
    }
    printf("\n\n");
    for (i = 0;i < 5; i++){
           if (anum[i] == q){//just shift for 00 or 11
               printf("\n-->");
               arshift();
               q = anum[i];
           }
           else if(anum[i] == 1 && q == 0){//subtract and shift for 10
              printf("\n-->");
              printf("\nSUB B: ");
              add(bcomp);//add two's complement to implement subtraction
              arshift();
              q = anum[i];
           }
           else{//add ans shift for 01
              printf("\n-->");
              printf("\nADD B: ");
              add(bnum);
              arshift();
              q = anum[i];
           }
     }
 
     printf("\nProduct is = ");
     for (i = 4; i >= 0; i--){
           printf("%d", pro[i]);
     }
     for (i = 4; i >= 0; i--){
           printf("%d", anumcp[i]);
     }
}
$ gcc booth.c -o booth
$ ./booth
 



BOOTHS MULTIPLICATION ALGORITHM
Enter two numbers to multiply: 12 12
Both must be less than 16
Enter A: Enter B: 
Expected product = 144
 
Binary Equivalents are: 
A = 01100
B = 01100
B'' + 1 = 10100
 
 
-->
AR-SHIFT: 00000:00110
-->
AR-SHIFT: 00000:00011
-->
SUB B: 10100:00011
AR-SHIFT: 11010:00001
-->
AR-SHIFT: 11101:00000
-->
ADD B: 01001:00000
AR-SHIFT: 00100:10000
Product is = 0010010000
 

VHDL
VHDL
• V : VHSIC (Very High Speed Integrated Circuit)
• H : Hardware
• D : Description
• L : Language
•	VHDL (VHSIC Hardware Description Language) is a hardware description language used in electronic design automation to describe digital and mixed-signal systems such as field-programmable gate arrays and integrated circuits.
•	VHDL can also be used as a general purpose parallel programming language.
•	VHDL is an industry standard hardware description language that is widely used for specifying, modeling, designing, and simulating digital systems.

VHDL Code

• Every piece of VHDL code is composed of at least three fundamental sections
• Library declarations: contains a list of all libraries to be used in the design
• Entity: specifies the I/O pins of the circuit
• Architecture: Contains the VHDL code which describes how the circuit should behave (function)

Library

• A library is a collection of commonly used pieces of code
• Placing such pieces inside a library allows them to be reused or shared by other designs
• To declare a library (that is to make it visible to the design) two lines of code are needed, one containing the name of the library, and the other a use clause
• LIBRARY library_name;
• Use Library_name.package_name.package_parts;

Entity

• An ENTITY is a list with specifications of all input and output pins (ports) of the circuit with the following syntax
ENTITY entity_name IS
PORT ( port_ name : signal_mode signal_type;
port_ name : signal_mode signal_type ;
... );
END entity_name;

• The mode of the signal can be IN, OUT, INOUT, or BUFFER
• IN and OUT are truly unidirectional pins, while INOUT is bidirectional
• BUFFER is employed when the output signal must be used (read) internally
• The name of the entity can be basically any name, except


VHDL reserved words

Input-Output

• Let my_ckt consists of following input & outputs
• Inputs: A, B, C
• Outputs: X, Y
• VHDL description is:
entity my_ckt is
port(

A: in bit;
B: in bit;
C: in bit;
X: out bit;
Y: out bit;

End my_ckt;

• Similarly for a two input NAND gate:
ENTITY nand_gate IS
PORT (a, b: IN BIT;
x: OUT BIT);
END nand_gate;

Architecture

• The ARCHITECTURE denotes the description of how the circuit should behave or function
• The syntax is as:
ARCHITECTURE architecture_name OF entity_name IS [declarations]
BEGIN
(code)
END architecture_name;
• An architecture has two parts : a declarative part (optional), where signals and constants (among others) are declared, and the code part (from BEGIN down)

Inverter in VHDL
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity invert_top is 
	Port (PB : in STD_LOGIC;
		LED : out STD_LOGIC);
end invert_top;
 
architecture Behavorial of invert_top is
begin
	--invert the signal from the push button switch and route it to the LED
	LED <= not PB;
end Behavioral;





AND gate

library ieee;
use ieee.std_logic_1164.all;

entity and_gate is

port ( a : in std_logic; -- AND gate input
b: in std_logic; -- AND gate input
y: out std_logic); -- AND gate output

end and_gate;

architecture behavioral of and_gate is
begin

y <= a and b; -- two input AND gate

end behavioral;

OR gate

library ieee;
use ieee.std_logic_1164.all;

entity or_gate is

port ( x1 : in std_logic; -- OR gate input
x2: in std_logic; -- OR gate input
y0: out std_logic); -- OR gate output

end and_gate;

architecture behavioral of or_gate is
begin

y0 <= x1 or x2; -- two input OR gate

end behavioral;

Multiplexer
library ieee;
use ieee.std_logic_1164.all;
entity mux is

port (a,b,c,d,s0,s1: in std_logic;
y: out std_logic);

end mux;
architecture pure_logic of mux is
begin

y<=(a and not s1 and not s0) or
(b and not s1 and s0) or
(c and s1 and not s0) or
(d and s1 and s0);

end pure_logic;

Full Adder
Library ieee;
use ieee.std_logic_1164.all;

entity full_adder is
port (a, b, c: in bit; sum, carry: out bit);
end full_adder;

architecture out_data of full_adder is
begin
sum <= a xor b xor c;
carry <= ((a and b) or (b and c) or (a and c));
end out_data;

Half Subtractor
Library ieee;
use ieee.std_logic_1164.all;

entity half_sub is
port(a, c: in bit; d, b: out bit);
end half_sub;

architecture data of half_sub is
begin
d <= a xor c;
b <= (a and (not c));
end data;

